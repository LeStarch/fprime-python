// ======================================================================
// \title  PyBindAc.cpp
// \brief  autocode python binding implementation
// ======================================================================
{% for ns, types in namespaces.items() %}
{% for item in types %}
{% if item.header_path != "" %}
#include <{{ item.header_path }}>
{%- endif -%}
{%- endfor %}
{%- endfor %}
#include <PyBindAc.hpp>

{% for ns, types in namespaces.items() %}
{% for item in types -%}
{% set cpp_class_name = item.ns + "::" + item.name -%}
{% if item.type == "Component" %}
namespace {{ item.ns }} {
    /**
     * {{ item.name }}: c++ function implementations that delegate across to the python side.
     */
    {{ item.name }} ::{{ item.name }}(const char* name) : {{ item.name }}ComponentBase(name) {}

    // init function loads python code
    void {{ item.name }} ::init({%- if item.kind != "passive" -%}const NATIVE_INT_TYPE queueDepth, {%- endif -%}const NATIVE_INT_TYPE instance) {
        py::gil_scoped_acquire acquired{};
        py::module_ module = py::module_::import("{{ item.name }}");
        this->m_self = module.attr("{{ item.name }}")();
        this->m_self.attr("_init_ac")(this);
        {{ item.name }}ComponentBase::init({%- if item.kind != "passive" -%}queueDepth, {%- endif -%}instance);
    }

    {{ item.name }} ::~{{ item.name }}() {}

    {% for in_port in item.in_ports -%}
    void {{ item.name }} ::{{ in_port.name }}_handler({{ ",".join(in_port.arg_full_texts) }}) {
        py::gil_scoped_acquire acquired{};
        m_self.attr("{{ in_port.name }}_handler")({{ functions.upcast_arguments(in_port.args) }});
    }
    {% endfor %}
    {% for command in item.commands -%}
    void {{ item.name }} ::{{ command.name }}_cmdHandler({{ ", ".join(command.arg_full_texts) }}) {
        py::gil_scoped_acquire acquired{};
        m_self.attr("{{ command.name }}_cmdHandler")({{ functions.upcast_arguments(command.args) }});
    }
    {% endfor %}
}; // Namespace {{ item.ns }}
{% endif %}
{% endfor %}

PYBIND11_EMBEDDED_MODULE({{ ns.replace("::", ".") }}, m) {
{% for item in types -%}
    {% set cpp_class_name = item.ns + "::" + item.name -%}
    {% if item.type == "Enum" %}
    py::class_<{{ cpp_class_name }}> _{{ item.name.lower() }}(m, "{{ item.name }}");
    _{{ item.name.lower() }}.def(py::init<>());
    _{{ item.name.lower() }}.def(py::init<{{ cpp_class_name }}::t>());
    _{{ item.name.lower() }}.def_readwrite("e", &{{ cpp_class_name }}::e);

    py::enum_<{{ cpp_class_name }}::t>(_{{ item.name.lower() }}, "t")
        {% for val in item.vals -%}
            .value("{{ val }}", {{ item.ns }}::{{ item.name }}::{{ val }})
        {% endfor -%}
        .export_values();
    {% elif item.type == "Array" %}
    py::class_<{{ cpp_class_name }}> _{{ item.name.lower() }}(m, "{{ item.name }}");
    _{{ item.name.lower() }}.def(py::init<>());
    _{{ item.name.lower() }}.def(py::init<{{ ",".join([item.elem_type] * item.size) }}>());
    _{{ item.name.lower() }}.def("__getitem__", [](const {{ cpp_class_name }} &a, int b) {
                return a[b];
            }, py::is_operator());
    _{{ item.name.lower() }}.def("__setitem__", []({{ cpp_class_name }} &a, int b, {{ item.elem_type }} c) {
                a[b] = c;
            }, py::is_operator());
    _{{ item.name.lower() }}.attr("size") = py::int_({{ item.size }});
    {% elif item.type == "Serializable" %}
    py::class_<{{ cpp_class_name }}>(m, "{{ item.name }}")
        .def(py::init<>())
        .def(py::init<{{ ",".join(item.member_list.values()) }}>())
        {%- for name in item.member_list.keys() %}
            .def("set{{ name }}", &{{ cpp_class_name }}::set{{ name }})
            .def("get{{ name }}", &{{ cpp_class_name }}::get{{ name }})
        {%- endfor -%};
    {% elif item.type == "Component" %}
    py::class_<{{ cpp_class_name }}>(m, "{{ item.name }}")
        {%- if item.kind == "queued" -%}
        .def("doDispatch", &{{ item.ns }}::{{ item.name }}::doDispatch)
        {%- endif -%}
        {% if item.commands %}
        .def("cmdResponse_out", &{{ item.ns }}::{{ item.name }}::cmdResponse_out)
        {%- endif -%}
        {% for out_port in item.out_ports %}
        .def("{{ out_port.name }}_out", &{{ item.ns }}::{{ item.name }}::{{ out_port.name }}_out)
        {%- endfor -%}
        {% for event in item.events %}
        .def("log_{{ event.severity }}_{{ event.name }}", &{{ item.ns }}::{{ item.name }}::log_{{ event.severity }}_{{ event.name }})
        {%- endfor -%}
        {% for channel in item.channels %}
        .def("tlmWrite_{{ channel.name }}", &{{ item.ns }}::{{ item.name }}::tlmWrite_{{ channel.name }},py::arg("arg"), py::arg("_tlmTime") = Fw::Time())
        {%- endfor -%};
    {% elif item.type == "string" %}
    py::class_<{{ cpp_class_name }}>(m, "{{ item.name }}")
        .def(py::init<char *>());
    {% endif %}
{% endfor %}
}
{%- endfor %}
